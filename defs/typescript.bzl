def _outputs(ctx, label, input_file):
  """Returns typescript output files for |input_file|.

  Args:
    ctx: ctx.
    label: Label. package label.
    input_file: File. the input_file
  Returns:
    A tuple of files (.js, .d.ts).
  """
  dot = input_file.short_path.rfind(".")
  beginning = len(label.package)
  if label.package:
    beginning += 1
  basename = input_file.short_path[beginning:dot]
  return (ctx.new_file(basename + ".js"),
          ctx.new_file(basename + ".d.ts"))

def _ts_library_impl(ctx):

  ### Collect srcs and outputs.
  srcs = ctx.files.srcs
  transpiled = []
  gen_declarations = []  # d.ts generated by the TypeScript compiler.
  for src in ctx.attr.srcs:
    for f in src.files:
      outs = _outputs(ctx, src.label, f)
      transpiled += [outs[0]]
      gen_declarations += [outs[1]]

  ctx.action(
    inputs = ctx.files.srcs + [ctx.file._tsc, ctx.file._lib],
    outputs = transpiled + gen_declarations,
    executable = ctx.file._node,
    arguments = [ctx.file._tsc.path, "--noLib", "--declaration", "--rootDir", ".",  "--outDir", ctx.bin_dir.path, ctx.file._lib.path] + [s.path for s in ctx.files.srcs]
    )
  return struct(
    files=set(transpiled),
  )

ts_library = rule(
  implementation = _ts_library_impl,
  attrs = {
    "srcs": attr.label_list(allow_files = True),
    "_node": attr.label(
        default = Label("@io_bazel_typescript_node//:bin/node"),
        allow_files = True,
        single_file = True),
    "_tsc": attr.label(
        default = Label("@yarn//node_modules:typescript/lib/tsc.js"),
        allow_files = True,
        single_file = True),
    "_lib": attr.label(
        default = Label("@yarn//node_modules:typescript/lib/lib.es5.d.ts"),
        allow_files = True,
        single_file = True),
  }
)
